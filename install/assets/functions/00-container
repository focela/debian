#!/command/with-contenv bash
#
# Container Helper Functions
# This script provides common utility functions for container initialization,
# service management, logging, and application setup.
#

set -euo pipefail
IFS=$'\n\t'

#--------------------------------------------------
# Configuration
#--------------------------------------------------

# Source the container defaults
source /assets/defaults/00-container

# Terminal colors for log output
BDG="\e[42m"    # Background green
BDB="\e[44m"    # Background blue
BDM="\e[45m"    # Background magenta
BDGY="\e[100m"  # Background gray
BLR="\e[101m"   # Background light red
BOFF="\e[49m"   # Reset background

# Log file setup
LOG_FILE="${CONTAINER_LOG_FILE_PATH}/${CONTAINER_LOG_FILE_NAME}"

#--------------------------------------------------
# Helper Functions
#--------------------------------------------------

# Check if container initialization scripts have completed
# Waits for /tmp/.container/99-container-init file to be created
check_container_initialized() {
  print_debug "Checking to see if container initialization scripts have completed"
  output_off

  while [[ ! -f /tmp/.container/99-container-init ]]; do
    print_debug "Checking to see if container initialization scripts have completed"
    sleep 1
  done

  output_on
}

# Check if a specific service has initialized
# Usage:
#   check_service_initialized init: Look for service-init file from cont-init.d scripts
#   check_service_initialized <service>: Look for service file from services.available
check_service_initialized() {
  print_debug "Checking to see if service has initialized"
  output_off

  local serviceSuffix=""
  local csiBypass="FALSE"
  local serviceName=""

  if [[ "$1" == "init" ]]; then
    serviceSuffix="-init"
    csiBypass="FALSE"
  else
    serviceName="$1"
    csiBypass="TRUE"
  fi

  if [[ "$csiBypass" == "FALSE" ]]; then
    if [[ -z "${2:-}" ]]; then
      case "$(dirname "$0")" in
        "/var/run/s6/etc/cont-init.d" | "/etc/cont-init.d" )
          serviceName=$(basename "$0")
        ;;
        *)
          serviceName=$(basename "$PWD")
        ;;
      esac
    else
      serviceName=$2
    fi
  fi

  while [[ ! -f /tmp/.container/"${serviceName}${serviceSuffix}" ]]; do
    sleep 1
    print_debug "Looking for existence of /tmp/.container/${serviceName}${serviceSuffix}"
  done

  output_on
}

# Clone a git repository with specified commit/branch
# Usage: clone_git_repo <repo_url> [commit/branch] [destination_dir]
clone_git_repo() {
  set +x
  if [[ "${DEBUG_MODE,,}" == "true" ]]; then set -x; fi

  if ! command -v git &> /dev/null; then
    echo '[clone_git_repo] Git is not installed' >&2
    return 1
  else
    git config --global init.defaultBranch main
  fi

  if [[ -n "$1" ]]; then
    local repoUrl="$1"
    local repoCommit="${2:-}"
    local appendGitPrefix=""
    local repoName=""
    local repoPath=""

    if [[ -n "${3:-}" ]]; then
      repoPath="${3}/"
      repoText="to '${3}'"
      repoName="$(echo ${repoUrl,,} | sed -e "s|-|_|g" -e "s|\.git||g" | awk -F/ '{print $NF}' | sed 's/[^a-zA-Z0-9_]//g')"
    else
      repoPath="/usr/src/$(echo ${repoUrl,,} | sed -e "s|-|_|g" -e "s|\.git||g" | awk -F/ '{print $NF}' | sed 's/[^a-zA-Z0-9_]//g')"
      repoName="$(echo ${repoUrl,,} | sed -e "s|-|_|g" -e "s|\.git||g" | awk -F/ '{print $NF}' | sed 's/[^a-zA-Z0-9_]//g')"
    fi

    export GIT_REPO_SRC=${GIT_REPO_SRC:-"${repoPath}"}
    export GIT_REPO_SRC_${repoName^^}="${repoPath}"

    if [[ -d "${repoPath}" ]]; then
      echo "[clone_git_repo] Directory ${repoPath} already exists. Cannot clone" >&2
      return 1
    else
      if [[ ! $repoUrl == *".git" ]]; then
        appendGitPrefix=".git"
      fi

      mkdir -p "${repoPath}" || {
        echo "[clone_git_repo] Failed to create directory ${repoPath}" >&2
        return 1
      }

      cd "${repoPath}" || {
        echo "[clone_git_repo] Failed to change to directory ${repoPath}" >&2
        return 1
      }

      git init .
      git remote add origin "${repoUrl}${appendGitPrefix}"
      echo "[clone_git_repo] Cloning Git Repo '${repoUrl}' '${repoCommit}' ${repoText:-}"

      git fetch --depth=1 origin ${repoCommit:-master} +refs/tags/*:refs/tags/* || {
        echo "[clone_git_repo] Failed to fetch from repository" >&2
        return 1
      }

      git fetch --depth 1 origin ${repoCommit:-master} || {
        echo "[clone_git_repo] Failed to fetch branch/commit" >&2
        return 1
      }

      git -c advice.detachedHead=false checkout FETCH_HEAD || {
        echo "[clone_git_repo] Failed to checkout" >&2
        return 1
      }

      git submodule update --init || {
        echo "[clone_git_repo] Failed to update submodules" >&2
        return 1
      }
    fi
  else
    echo "[clone_git_repo] You tried to call the function but there's no arguments" >&2
    return 1
  fi

  set -x
}

# Create a logrotate configuration file
# Usage: create_logrotate <name> <path> [logship_parser] [user] [group]
create_logrotate() {
  if [[ -n "$1" && -n "$2" ]]; then
    if [[ ! -f /assets/logrotate/"$1" ]]; then
      print_debug "Creating Logrotate Entry for $2"
      local lrlsparser=""
      local lruser=""

      if [[ -n "${3:-}" ]]; then
        if [[ "${3,,}" != "none" ]]; then
          lrlsparser="# logship: $3"
        fi
      fi

      if [[ -n "${4:-}" && -n "${5:-}" ]]; then
        lruser="    su $4 $5"
      fi

      if [[ ! -d "/assets/logrotate" ]]; then
        mkdir -p /assets/logrotate || {
          print_error "Failed to create logrotate directory"
          return 1
        }
      fi

      cat <<EOF > /assets/logrotate/"${1}"
${lrlsparser}
$2 {
    missingok
${lruser}
}
EOF
      chown root:root /assets/logrotate/"${1}"
      chmod 0644 /assets/logrotate/"${1}"
    else
      print_debug "Skipping creating automatic logrotation for ${1}"
    fi
  fi
}

# Create a Zabbix autoregister configuration
# Usage: create_zabbix <service_name> [autoregister_name]
create_zabbix() {
  if [[ -n "$1" ]]; then
    local autoregister

    if [[ -n "${2:-}" ]]; then
      autoregister=$2
    else
      autoregister=$1
    fi

    print_debug "Adding Zabbix Auto Register configuration for '$1'"

    if var_true "${CONTAINER_ENABLE_MONITORING}" && [[ "${CONTAINER_MONITORING_BACKEND,,}" == "zabbix" ]]; then
      source /assets/defaults/03-monitoring

      cat <<EOF > "${ZABBIX_CONFIG_PATH}/${ZABBIX_CONFIG_FILE}.d/focela_$1.conf"
# Zabbix $1 Configuration - Automatically Generated
# Autoregister=$autoregister
EOF
    fi
  fi
}

# Copy custom files to a destination directory
# Usage: custom_files [source_dir] <destination_dir> [owner] [group]
custom_files() {
  local customFilesSource
  local customFilesDestination
  local permbuilder=""

  if [[ -n "${2:-}" ]]; then
    customFilesSource="${1}"
    customFilesDestination="${2}"
  else
    customFilesSource="${CONTAINER_CUSTOM_PATH}"
    customFilesDestination="${1}"
  fi

  if [[ -d "${customFilesSource}" ]] && dir_notempty "${customFilesSource}"; then
    print_debug "Custom Files: Copying files from '${customFilesSource}' to '${customFilesDestination}'"

    if [[ ! -d "${customFilesDestination}" ]]; then
      mkdir -p "${customFilesDestination}" || {
        print_error "Failed to create destination directory ${customFilesDestination}"
        return 1
      }
    fi

    cp -aR "${customFilesSource}"/* "${customFilesDestination}"/ || {
      print_error "Failed to copy files to ${customFilesDestination}"
      return 1
    }
  fi

  if [[ -n "${3:-}" ]]; then
    permbuilder="${3}"
  fi

  if [[ -n "${4:-}" ]]; then
    permbuilder="${3}:${4}"
  fi

  if [[ -n "${permbuilder}" ]]; then
    chown -R "${permbuilder}" "${customFilesDestination}" || {
      print_error "Failed to set permissions on ${customFilesDestination}"
      return 1
    }
  fi
}

# Execute custom scripts from a directory
# Usage: custom_scripts [scripts_directory]
custom_scripts() {
  local customScriptsSource

  if [[ -n "${1:-}" ]]; then
    customScriptsSource="${1}"
  else
    customScriptsSource="${CONTAINER_CUSTOM_SCRIPTS_PATH}"
  fi

  if [[ -d "${customScriptsSource}" ]] && dir_notempty "${customScriptsSource}"; then
    for customScript in "${customScriptsSource}"/*.sh; do
      if [[ -x "$customScript" && ! -d "$customScript" ]]; then
        print_debug "Custom Script executing: '${customScript}'"
        ${customScript} || {
          print_warn "Custom script ${customScript} exited with non-zero status"
        }
      fi
    done
  fi
}

# Wait for a database to be ready
# Usage: db_ready <database_type>
db_ready() {
  output_off
  print_debug "Checking to see if Database Type $1 is ready"

  case "${1,,}" in
    "couch" | "couchdb" )
      transform_file_var DB_PORT
      local couchPort=${DB_PORT:-}
      transform_file_var COUCHDB_PORT

      if [[ -n "${COUCHDB_PORT:-}" ]]; then
        couchPort=${COUCHDB_PORT}
      fi

      couchPort=${couchPort:-5984}

      transform_file_var DB_HOST
      local couchHost=${DB_HOST:-}
      transform_file_var COUCHDB_HOST

      if [[ -n "${COUCHDB_HOST:-}" ]]; then
        couchHost=${COUCHDB_HOST}
      fi

      local counter=0
      while ! nc -z "${couchHost}" ${couchPort}; do
        sleep 5
        ((counter+=5))
        print_warn "CouchDB Host '${couchHost}' is not accessible, retrying.. ($counter seconds so far)"
      done
    ;;
    "influx" | "influxdb" )
      transform_file_var DB_PORT
      local influxPort=${DB_PORT:-}
      transform_file_var INFLUXDB_PORT

      if [[ -n "${INFLUXDB_PORT:-}" ]]; then
        influxPort=${INFLUXDB_PORT}
      fi

      influxPort=${influxPort:-8088}

      transform_file_var DB_HOST
      local influxHost=${DB_HOST:-}
      transform_file_var INFLUXDB_HOST

      if [[ -n "${INFLUXDB_HOST:-}" ]]; then
        influxHost=${INFLUXDB_HOST}
      fi

      local counter=0
      while ! nc -z "${influxHost}" "${influxPort}"; do
        sleep 5
        ((counter+=5))
        print_warn "InfluxDB Host '${influxHost}' is not accessible, retrying.. ($counter seconds so far)"
      done
    ;;
    "mongo" | "mongodb" )
      transform_file_var DB_PORT
      local mongoPort=${DB_PORT:-}
      transform_file_var MONGO_PORT

      if [[ -n "${MONGO_PORT:-}" ]]; then
        mongoPort=${MONGO_PORT}
      fi

      mongoPort=${mongoPort:-27017}

      transform_file_var DB_HOST
      local mongoHost=${DB_HOST:-}
      transform_file_var MONGO_HOST

      if [[ -n "${MONGO_HOST:-}" ]]; then
        mongoHost=${MONGO_HOST}
      fi

      local counter=0
      while ! nc -z "${mongoHost}" "${mongoPort}"; do
        sleep 5
        ((counter+=5))
        print_warn "Mongo Host '${mongoHost}' is not accessible, retrying.. ($counter seconds so far)"
      done
    ;;
    "mysql" | "mariadb" )
      local mysqladminBin

      if command -v "mariadb-admin" &> /dev/null; then
        mysqladminBin="$(which mariadb-admin)"
      elif command -v "mysqladmin" &> /dev/null; then
        mysqladminBin="$(which mysqladmin)"
      else
        print_error "No MySQL or MariaDB client detected - Cannot check for Database"
        return 1
      fi

      if [[ ! -f /etc/my.cnf.d/disable-ssl.cnf ]]; then
        mkdir -p /etc/my.cnf.d || {
          print_error "Failed to create my.cnf.d directory"
          return 1
        }

        cat <<EOF > /etc/my.cnf.d/disable-ssl.cnf
[client]
ssl=FALSE
EOF
      fi

      transform_file_var DB_PORT
      local mariaPort=${DB_PORT:-}
      transform_file_var MYSQL_PORT

      if [[ -n "${MYSQL_PORT:-}" ]]; then
        mariaPort=${MYSQL_PORT}
      fi

      transform_file_var MARIA_PORT

      if [[ -n "${MARIA_PORT:-}" ]]; then
        mariaPort=${MARIA_PORT}
      fi

      mariaPort=${mariaPort:-3306}

      transform_file_var DB_HOST
      local mariaHost=${DB_HOST:-}
      transform_file_var MYSQL_HOST

      if [[ -n "${MYSQL_HOST:-}" ]]; then
        mariaHost=${MYSQL_HOST}
      fi

      transform_file_var MARIA_HOST

      if [[ -n "${MARIA_HOST:-}" ]]; then
        mariaHost=${MARIA_HOST}
      fi

      transform_file_var DB_USER
      local mariaUser=${DB_USER:-}
      transform_file_var MYSQL_USER

      if [[ -n "${MYSQL_USER:-}" ]]; then
        mariaUser=${MYSQL_USER}
      fi

      transform_file_var MARIA_USER

      if [[ -n "${MARIA_USER:-}" ]]; then
        mariaUser=${MARIA_USER}
      fi

      transform_file_var DB_PASS
      local mariaPass=${DB_PASS:-}
      transform_file_var MYSQL_PASS

      if [[ -n "${MYSQL_PASS:-}" ]]; then
        mariaPass=${MYSQL_PASS}
      fi

      transform_file_var MARIA_PASS

      if [[ -n "${MARIA_PASS:-}" ]]; then
        mariaPass=${MARIA_PASS}
      fi

      transform_file_var DB_NAME
      local mariaName=${DB_NAME:-}
      transform_file_var MYSQL_NAME

      if [[ -n "${MYSQL_NAME:-}" ]]; then
        mariaName=${MYSQL_NAME}
      fi

      transform_file_var MARIA_NAME

      if [[ -n "${MARIA_NAME:-}" ]]; then
        mariaName=${MARIA_NAME}
      fi

      local counter=0
      while ! "${mysqladminBin}" -u"${mariaUser}" -P"${mariaPort}" -h"${mariaHost}" -p"${mariaPass}" status > /dev/null 2>&1; do
        sleep 5
        ((counter+=5))
        print_warn "MySQL/MariaDB Server '${mariaHost}' is not accessible, retrying.. (${counter} seconds so far)"
      done
    ;;
    "pgsql" | "psql" | "postgres" | "postgresql" )
      local pgIsreadyBin

      if command -v "pg_isready" &> /dev/null; then
        pgIsreadyBin="$(which pg_isready)"
      else
        print_error "No Postgresql client installation detected - Cannot check for Database"
        return 1
      fi

      transform_file_var DB_PORT
      local postgresPort=${DB_PORT:-}
      transform_file_var POSTGRES_PORT

      if [[ -n "${POSTGRES_PORT:-}" ]]; then
        postgresPort=${POSTGRES_PORT}
      fi

      postgresPort=${postgresPort:-5432}

      transform_file_var DB_HOST
      local postgresHost=${DB_HOST:-}
      transform_file_var POSTGRES_HOST

      if [[ -n "${POSTGRES_HOST:-}" ]]; then
        postgresHost=${POSTGRES_HOST}
      fi

      transform_file_var DB_USER
      local postgresUser=${DB_USER:-}
      transform_file_var POSTGRES_USER

      if [[ -n "${POSTGRES_USER:-}" ]]; then
        postgresUser=${POSTGRES_USER}
      fi

      transform_file_var DB_PASS
      local postgresPass=${DB_PASS:-}
      transform_file_var PGPASSWORD

      if [[ -n "${PGPASSWORD:-}" ]]; then
        postgresPass=${PGPASSWORD}
      fi

      transform_file_var DB_NAME
      local postgresName=${DB_NAME:-}
      transform_file_var POSTGRES_NAME

      if [[ -n "${POSTGRES_NAME:-}" ]]; then
        postgresName=${POSTGRES_NAME}
      fi

      local counter=0
      export PGPASSWORD=${postgresPass}

      until "${pgIsreadyBin}" --dbname="${postgresName}" --host="${postgresHost}" --port="${postgresPort}" --username="${postgresUser}" -q; do
        sleep 5
        ((counter+=5))
        print_warn "Postgres Host '${postgresHost}' is not accessible, retrying.. ($counter seconds so far)"
      done
    ;;
    "rabbit" | "rabbitmq" )
      transform_file_var DB_PORT
      local rabbitPort=${DB_PORT:-}
      transform_file_var RABBIT_PORT

      if [[ -n "${RABBIT_PORT:-}" ]]; then
        rabbitPort=${RABBIT_PORT}
      fi

      rabbitPort=${rabbitPort:-5672}

      transform_file_var DB_HOST
      local rabbitHost=${DB_HOST:-}
      transform_file_var RABBIT_HOST

      if [[ -n "${RABBIT_HOST:-}" ]]; then
        rabbitHost=${RABBIT_HOST}
      fi

      local counter=0
      while ! nc -z "${rabbitHost}" "${rabbitPort}"; do
        sleep 5
        ((counter+=5))
        print_warn "RabbitMQ Host '${rabbitHost}' is not accessible, retrying.. ($counter seconds so far)"
      done
    ;;
    "redis" )
      transform_file_var DB_PORT
      local redisPort=${DB_PORT:-}

      if [[ -n "${DB_PORT_FILE:-}" ]]; then
        redisPort="$(cat "${DB_PORT_FILE}")" || {
          print_error "Failed to read DB_PORT_FILE"
          return 1
        }
      fi

      if [[ -n "${REDIS_PORT:-}" ]]; then
        redisPort=${REDIS_PORT}
      fi

      redisPort=${redisPort:-6379}

      transform_file_var DB_HOST
      local redisHost=${DB_HOST:-}
      transform_file_var REDIS_HOST

      if [[ -n "${REDIS_HOST:-}" ]]; then
        redisHost=${REDIS_HOST}
      fi

      local counter=0
      while ! nc -z "${redisHost}" "${redisPort}"; do
        sleep 5
        ((counter+=5))
        print_warn "Redis Host '${redisHost}' is not accessible, retrying.. ($counter seconds so far)"
      done
    ;;
    "rethink" )
      transform_file_var DB_PORT
      local rethinkPort=${DB_PORT:-}

      if [[ -n "${DB_PORT_FILE:-}" ]]; then
        rethinkPort="$(cat "${DB_PORT_FILE}")" || {
          print_error "Failed to read DB_PORT_FILE"
          return 1
        }
      fi

      if [[ -n "${RETHINK_PORT:-}" ]]; then
        rethinkPort=${RETHINK_PORT}
      fi

      rethinkPort=${rethinkPort:-28015}

      transform_file_var DB_HOST
      local rethinkHost=${DB_HOST:-}
      transform_file_var RETHINK_HOST

      if [[ -n "${RETHINK_HOST:-}" ]]; then
        rethinkHost=${RETHINK_HOST}
      fi

      local counter=0
      while ! nc -z "${rethinkHost}" "${rethinkPort}"; do
        sleep 5
        ((counter+=5))
        print_warn "RethinkDB Host '${rethinkHost}' is not accessible, retrying.. ($counter seconds so far)"
      done
    ;;
  esac
  output_on
}

# Check if a directory is empty
# Usage: dir_empty <directory>
dir_empty() {
  [[ ! -n "$(ls -A "$1" 2>/dev/null)" ]]
}

# Check if a directory is not empty
# Usage: dir_notempty <directory>
dir_notempty() {
  [[ -n "$(ls -A "$1" 2>/dev/null)" ]]
}

# Load environment variables from files with _FILE suffix
# Usage: file_env <var_name> [default_value]
file_env() {
  if [[ "${CONTAINER_ENABLE_DOCKER_SECRETS,,}" == "true" ]]; then
    local var="$1"
    local fileVar="${var}_FILE"
    local def="${2:-}"
    local val="$def"

    if [[ -n "${!fileVar:-}" ]]; then
      val="$(cat "${!fileVar}")" || {
        print_error "Failed to read ${fileVar} file ${!fileVar}"
        return 1
      }
    elif [[ -n "${!var:-}" ]]; then
      val="${!var}"
    fi

    if [[ -z "${val}" ]]; then
      print_error "error: neither $var nor $fileVar are set but are required"
      return 1
    fi

    export "$var"="$val"
    unset "$fileVar"
  fi
}

# Source default environment variables from /assets/defaults/
# Usage: get_defaults [all|app|single|comma_separated_list]
get_defaults() {
  if [[ -n "${1:-}" ]]; then
    case "${1,,}" in
      "all" )
        for d in /assets/defaults/*; do
          print_debug "Container: Getting defaults for '${d}' ALL"
          case "$(basename "${d}")" in
            0*-* | 99-* )
              output_off
              source "${d}" || {
                print_error "Failed to source ${d}"
                return 1
              }
              output_on
            ;;
            * )
              source "${d}" || {
                print_error "Failed to source ${d}"
                return 1
              }
            ;;
          esac
        done
      ;;
      "app" | "single" )
        case "$(dirname "$0")" in
          "/var/run/s6/etc/cont-init.d" | "/etc/cont-init.d" )
            if [[ -f "/assets/defaults/$(basename "$0")" ]]; then
              print_debug "Container: Getting defaults for '$(basename "$0")'"
              case "$(basename "$0")" in
                0*-* | 99-* )
                  output_off
                  source /assets/defaults/"$(basename "$0")" || {
                    print_error "Failed to source /assets/defaults/$(basename "$0")"
                    return 1
                  }
                  output_on
                ;;
                * )
                  source /assets/defaults/"$(basename "$0")" || {
                    print_error "Failed to source /assets/defaults/$(basename "$0")"
                    return 1
                  }
                ;;
              esac
            else
              print_debug "Container: No defaults available for '$(basename "$0")'"
            fi
          ;;
          *)
            if [[ -f "/assets/defaults/$(basename "$PWD")" ]]; then
              print_debug "Container: Getting defaults for '$(basename "$PWD")'"
              case "$(basename "$PWD")" in
                0*-* | 99-* )
                  output_off
                  source /assets/defaults/"$(basename "$PWD")" || {
                    print_error "Failed to source /assets/defaults/$(basename "$PWD")"
                    return 1
                  }
                  output_on
                ;;
                * )
                  source /assets/defaults/"$(basename "$PWD")" || {
                    print_error "Failed to source /assets/defaults/$(basename "$PWD")"
                    return 1
                  }
                ;;
              esac
            else
              print_debug "Container: No defaults available for $(basename "$PWD")"
            fi
          ;;
        esac
      ;;
      * )
        local defaults
        defaults=$(echo "$1" | tr "," "\n")
        for d in $defaults; do
          if [[ -f "/assets/defaults/${d}" ]]; then
            print_debug "Container: Getting defaults for $d"
            case "${d}" in
              0*-* | 99-* )
                output_off
                source /assets/defaults/"${d}" || {
                  print_error "Failed to source /assets/defaults/${d}"
                  return 1
                }
                output_on
              ;;
              * )
                source /assets/defaults/"${d}" || {
                  print_error "Failed to source /assets/defaults/${d}"
                  return 1
                }
              ;;
            esac
          else
            print_debug "Container: No defaults available for '${d}'"
          fi
        done
      ;;
    esac
  else
    for d in /assets/defaults/*; do
      print_debug "Container: Getting defaults for $d"
      case "$(basename "${d}")" in
        0*-* | 99-* )
          output_off
          source /assets/defaults/00-container || {
            print_error "Failed to source /assets/defaults/00-container"
            return 1
          }
          source "${d}" || {
            print_error "Failed to source ${d}"
            return 1
          }
          output_on
        ;;
        * )
          source /assets/defaults/00-container || {
            print_error "Failed to source /assets/defaults/00-container"
            return 1
          }
          source "${d}" || {
            print_error "Failed to source ${d}"
            return 1
          }
        ;;
      esac
    done
  fi
}

# Source function libraries from /assets/functions/
# Usage: get_functions [all|app|single|comma_separated_list]
get_functions() {
  if [[ -n "${1:-}" ]]; then
    case "${1,,}" in
      "all" )
        for f in /assets/functions/*; do
          if [[ "$f" != "/assets/functions/00-container" ]]; then
            print_debug "Container: Getting functions for '${f}'"
            source "$f" || {
              print_error "Failed to source ${f}"
              return 1
            }
          fi
        done
      ;;
      "app" | "single" )
        case "$(dirname "$0")" in
          "/var/run/s6/etc/cont-init.d" | "/etc/cont-init.d" )
            if [[ -f "/assets/functions/$(basename "$0")" ]]; then
              print_debug "Container: Getting functions for '$(basename "$0")'"
              source /assets/functions/"$(basename "$0")" || {
                print_error "Failed to source /assets/functions/$(basename "$0")"
                return 1
              }
            else
              print_debug "Container: No functions available for '$(basename "$0")'"
            fi
          ;;
          *)
            if [[ -f "/assets/functions/$(basename "$PWD")" ]]; then
              print_debug "Container: Getting functions for '$(basename "$PWD")'"
              source /assets/functions/"$(basename "$PWD")" || {
                print_error "Failed to source /assets/functions/$(basename "$PWD")"
                return 1
              }
            else
              print_debug "Container: No functions available for $(basename "$PWD")"
            fi
          ;;
        esac
      ;;
      * )
        local functions
        functions=$(echo "$1" | tr "," "\n")
        for f in $functions; do
          if [[ -f "/assets/functions/${f}" ]]; then
            print_debug "Container: Getting functions for $f"
            source /assets/functions/"${f}" || {
              print_error "Failed to source /assets/functions/${f}"
              return 1
            }
          else
            print_debug "Container: No functions available for '$f'"
          fi
        done
      ;;
    esac
  else
    for f in /assets/functions/*; do
      if [[ "$f" != "/assets/functions/00-container" ]]; then
        print_debug "Container: Getting functions for $f"
        source "${f}" || {
          print_error "Failed to source ${f}"
          return 1
        }
      fi
    done
  fi
}

# Get the image version from changelog files
# Returns the version as a string
get_image_version() {
  output_off
  local imageVersion=""

  if [[ -n "${IMAGE_NAME:-}" ]]; then
    if [[ -f "/assets/.changelogs/${IMAGE_NAME/\//_}.md" ]]; then
      imageVersion=$(head -n1 /assets/.changelogs/${IMAGE_NAME/\//_}.md | awk '{print $2}')
    elif [[ -f /assets/.changelogs/docker-${IMAGE_NAME/\//_}.md ]]; then
      imageVersion=$(head -n1 /assets/.changelogs/docker-${IMAGE_NAME/\//_}.md | awk '{print $2}')
    else
      if [[ -f /assets/.changelogs/focela_docker-${IMAGE_NAME/\//_}.md ]]; then
        imageVersion=$(head -n1 /assets/.changelogs/docker-${IMAGE_NAME/\//_}.md | awk '{print $2}')
      else
        local stripImageRepoUrl
        stripImageRepoUrl=$(echo ${IMAGE_REPO_URL%/} | sed "s#https://github.com/##g")

        if [[ -f /assets/.changelogs/${stripImageRepoUrl/\//_}.md ]]; then
          imageVersion=$(head -n1 /assets/.changelogs/${stripImageRepoUrl/\//_}.md | awk '{print $2}')
        fi
      fi

      if [[ -f /assets/.changelogs/focela_docker-${IMAGE_NAME/\//_}.md ]]; then
        imageVersion=$(head -n1 /assets/.changelogs/focela_docker-${IMAGE_NAME/\//_}.md | awk '{print $2}')
      fi
    fi

    if [[ -n "${imageVersion}" ]]; then
      echo "${imageVersion}"
    fi
  fi
  output_on
}

# Grant doas privileges to a user
# Usage: grant_doas <username> [command]
grant_doas() {
  output_off
  if [[ -n "$1" ]]; then
    print_debug "Adding Doas privileges to '$1'"
    local doasCommand=""

    if [[ -n "${2:-}" ]]; then
      print_debug "Adding doas privileges to '$1' for '${2}' command"
      doasCommand="cmd $2"
    fi

    echo "permit nopass $1 ${doasCommand} as root" >> /etc/doas.conf
    chown root:root /etc/doas.conf || {
      print_error "Failed to set ownership on /etc/doas.conf"
      return 1
    }

    chmod 0400 -R /etc/doas.conf || {
      print_error "Failed to set permissions on /etc/doas.conf"
      return 1
    }
  fi
  output_on
}

# Grant sudo privileges to a user
# Usage: grant_sudo <username> [command]
grant_sudo() {
  output_off
  if [[ -n "$1" ]]; then
    local sudoCommand="ALL"

    if [[ -n "${2:-}" ]]; then
      sudoCommand="$2"
    fi

    print_debug "Adding Sudo privileges to '$1' for '${sudoCommand}' command"
    echo "%$1 ALL=(ALL) NOPASSWD:${sudoCommand}" >> /etc/sudoers
  fi
  output_on
}

# Add host entries to /etc/hosts from CONTAINER_HOST_OVERRIDE_XX variables
# Usage: host_override
host_override() {
  local hostNum
  hostNum=$(printenv | sort | grep -cE '^CONTAINER_HOST_OVERRIDE_([0-9].)')

  for (( i = 1; i <= hostNum; i++ )); do
    local hostId
    hostId=$(printf "%02d" $i)
    local hostLine="CONTAINER_HOST_OVERRIDE_${hostId}"
    local hostIp
    hostIp=$(echo ${!hostLine} | awk '{print $1}')

    if [[ ! "${hostIp}" =~ ^[0-9]+\.[0-9]+\.[0-9]+\.[0-9]+$ ]]; then
      hostIp="$(getent ahostsv4 "${hostIp}" | grep -m 1 STREAM | awk '{print $1}')"
    fi

    echo "# Added automatically by CONTAINER_HOST_OVERRIDE_${hostId}" >> /etc/hosts
    echo "${hostIp} $(echo ${!hostLine} | cut -d' ' -f2-)" >> /etc/hosts
  done
}

# Install a template file with proper permissions
# Usage: install_template <owner:group> <source> <destination> [mode]
install_template() {
  if [[ -z "$1" || -z $2 || -z $3 ]]; then
    print_error "[install_template] No arguments passed"
    return 1
  fi

  local templateMode=${4:-"0644"}

  if [[ ! -f "$2" ]]; then
    print_error "[install_template] Can't find ${2}"
    return 1
  fi

  if [[ ! -d "$(dirname $3)" ]]; then
    mkdir -p "$(dirname $3)" || {
      print_error "[install_template] Failed to create directory $(dirname $3)"
      return 1
    }
  fi

  cp -f "$2" "$3" || {
    print_error "[install_template] Failed to copy template"
    return 1
  }

  chmod "${templateMode}" "${3}" || {
    print_error "[install_template] Failed to set permissions on ${3}"
    return 1
  }

  chown "${1}" "${3}" || {
    print_error "[install_template] Failed to set ownership on ${3}"
    return 1
  }
}

# Generate a log prefix with timestamp
# Returns: timestamp string according to configuration
log_prefix() {
  output_off
  if [[ "${CONTAINER_ENABLE_LOG_PREFIX,,}" == "true" ]]; then
    echo "$(date +"${CONTAINER_LOG_PREFIX_DATE_FMT}")${CONTAINER_LOG_PREFIX_SEPERATOR}$(date +"${CONTAINER_PROCESS_HELPER_TIME_FMT}") "
  fi
  output_on
}

# Mark a service as initialized
# Usage: liftoff
liftoff() {
  output_off
  mkdir -p /tmp/.container || {
    print_error "Failed to create /tmp/.container directory"
    return 1
  }

  local liftoffPrefix=""

  if [[ "${DONOTSTART:-}" == "TRUE" ]]; then
    liftoffPrefix="DONOTSTART "
  fi

  case "$(dirname "$0")" in
    "/var/run/s6/etc/cont-init.d" | "/etc/cont-init.d" )
      echo "${liftoffPrefix}$(basename "$0")-init initialized on $(log_prefix)" >> /tmp/.container/"$(basename "$0")"-init
    ;;
    *)
      if [[ ! -f /tmp/.container/"$(basename "$PWD")" ]]; then
        echo "$(basename "$PWD") initialized on $(log_prefix)" >> /tmp/.container/"$(basename "$PWD")"
      else
        echo "$(basename "$PWD") reinitialized on $(log_prefix)" >> /tmp/.container/"$(basename "$PWD")"
      fi
    ;;
  esac
  output_on
}

# Disable debug output
output_off() {
  if [[ "${DEBUG_MODE,,}" == "true" ]]; then
    set +x
  fi
}

# Enable debug output if DEBUG_MODE is true
output_on() {
  if [[ "${DEBUG_MODE,,}" == "true" ]]; then
    case "$(basename "$0")" in
      0*-* | 99-* )
        :
      ;;
      run )
        case "$PWD" in
          */0*-* | 99-* )
            :
          ;;
          * )
            set -x
          ;;
        esac
      ;;
      * )
        set -x
      ;;
    esac
  fi
}

# Perform package management operations
# Usage: package <action> [args...]
package() {
  # Clean up package manager cache
  cleanup() {
    case "${distro}" in
      "alpine" )
        rm -rf /root/.gitconfig
        rm -rf /var/cache/apk/*
      ;;
      "debian" | "ubuntu" )
        apt-get clean -y
        rm -rf /root/.gitconfig
        rm -rf /var/lib/apt/lists/*
      ;;
    esac
  }

  # Install packages
  install() {
    case "${distro}" in
      "alpine" )
        if [[ "${1}" =~ ^\..* ]]; then
          local dependencies="-t"
        fi
        apk add ${dependencies} "$@" || {
          print_error "Failed to install Alpine packages: $*"
          return 1
        }
      ;;
      "debian" | "ubuntu" )
        if [[ "${1}" =~ ^\..* ]]; then
          shift
        fi
        apt-get install -y --no-install-recommends "$@" || {
          print_error "Failed to install Debian packages: $*"
          return 1
        }
      ;;
    esac
  }

  # Remove packages
  remove() {
    case "${distro}" in
      "alpine" )
        apk del "$@" || {
          print_error "Failed to remove Alpine packages: $*"
          return 1
        }
      ;;
      "debian" | "ubuntu" )
        local packages="$@"
        if [[ "${packages}" =~ \..* ]]; then
          packages=$(echo "${packages}" | sed "s|\..* ||g")
        fi
        apt-get purge -y ${packages} || {
          print_error "Failed to purge Debian packages: ${packages}"
          return 1
        }
        apt-get autoremove -y || {
          print_error "Failed to autoremove Debian packages"
          return 1
        }
      ;;
    esac
  }

  # Update package index
  update() {
    case "${distro}" in
      "alpine" )
        apk update || {
          print_error "Failed to update Alpine package index"
          return 1
        }
      ;;
      "debian" | "ubuntu" )
        apt-get update || {
          print_error "Failed to update Debian package index"
          return 1
        }
      ;;
    esac
  }

  # Upgrade installed packages
  upgrade() {
    case "${distro}" in
      "alpine" )
        apk upgrade || {
          print_error "Failed to upgrade Alpine packages"
          return 1
        }
      ;;
      "debian" | "ubuntu" )
        apt-get upgrade -y || {
          print_error "Failed to upgrade Debian packages"
          return 1
        }
      ;;
    esac
  }

  output_off
  local distro
  distro=$(cat /etc/os-release | grep ^ID= | cut -d = -f2)
  local action="${1}"
  shift
  local arguments=$@

  case "${action}" in
    add | install )
      action=install
      "${action}" "${arguments}"
    ;;
    delete | remove | uninstall )
      action=remove
      "${action}" "${arguments}"
    ;;
    * )
      "${action}" "${arguments}"
    ;;
  esac
  output_on
}

# Prepare service by sourcing defaults and functions
# Usage: prepare_service [what] [name]
prepare_service() {
  if [[ -n "${1:-}" ]]; then
    case "$(dirname "$0")" in
      "/var/run/s6/etc/cont-init.d" | "/etc/cont-init.d" )
        set -a
        get_defaults "$1"
        get_functions "$1"
        set +a
      ;;
      *)
        case "$1" in
          "BOTH" | "both" | "ALL" | "all" )
            get_defaults "$2"
            get_functions "$2"
          ;;
          "DEFAULTS" | "defaults" )
            get_defaults "$2"
          ;;
          "FUNCTIONS" | "functions" )
            get_functions "$2"
          ;;
        esac
      ;;
    esac
  else
    case "$(dirname "$0")" in
      "/var/run/s6/etc/cont-init.d" | "/etc/cont-init.d")
        set -a
        get_defaults
        get_functions
        set +a
      ;;
      *)
        get_defaults
      ;;
    esac
  fi
}

# Log a debug message
# Usage: print_debug <message>
print_debug() {
  output_off
  case "${CONTAINER_LOG_LEVEL,,}" in
    "debug" )
      if [[ "${DEBUG_MODE,,}" == "true" ]]; then
        if [[ "${CONTAINER_COLORIZE_OUTPUT,,}" == "false" ]]; then
          echo -e "$(log_prefix)[DEBUG] $SCRIPTPATH/$(basename "$0") ** [${PROCESS_NAME}] $1"
        else
          echo -e "$(log_prefix)${BDM}[DEBUG]${BOFF} $SCRIPTPATH/$(basename "$0") ** [${PROCESS_NAME}] $1"
        fi
      else
        if [[ "${CONTAINER_COLORIZE_OUTPUT,,}" == "false" ]]; then
          echo -e "$(log_prefix)[DEBUG] ** [${PROCESS_NAME}] $1"
        else
          echo -e "$(log_prefix)${BDM}[DEBUG]${BOFF} ** [${PROCESS_NAME}] $1"
        fi
      fi
    ;;
  esac

  case "${CONTAINER_LOG_FILE_LEVEL,,}" in
    "debug" )
      echo -e "$(log_prefix)[DEBUG] $SCRIPTPATH/$(basename "$0") ** [${PROCESS_NAME}] $1" >> "${LOG_FILE}"
    ;;
  esac
  output_on
}

# Log an error message
# Usage: print_error <message>
print_error() {
  output_off
  case "${CONTAINER_LOG_LEVEL,,}" in
    "debug" | "notice" | "warn" | "error")
      if [[ "${DEBUG_MODE,,}" == "true" ]]; then
        if [[ "${CONTAINER_COLORIZE_OUTPUT,,}" == "false" ]]; then
          echo -e "$(log_prefix)[ERROR] $SCRIPTPATH/$(basename "$0") ** [${PROCESS_NAME}] $1"
        else
          echo -e "$(log_prefix)${BLR}[ERROR]${BOFF} $SCRIPTPATH/$(basename "$0") ** [${PROCESS_NAME}] $1"
        fi
      else
        if [[ "${CONTAINER_COLORIZE_OUTPUT,,}" == "false" ]]; then
          echo -e "$(log_prefix)[ERROR] ** [${PROCESS_NAME}] $1"
        else
          echo -e "$(log_prefix)${BLR}[ERROR]${BOFF} ** [${PROCESS_NAME}] $1"
        fi
      fi
    ;;
  esac

  case "${CONTAINER_LOG_FILE_LEVEL,,}" in
    "debug" | "notice" | "warn" | "error")
      echo -e "$(log_prefix)[ERROR] $SCRIPTPATH/$(basename "$0") ** [${PROCESS_NAME}] $1" >> "${LOG_FILE}"
    ;;
  esac
  output_on
}

# Log an info message
# Usage: print_info <message>
print_info() {
  output_off
  if [[ "${DEBUG_MODE,,}" == "true" ]]; then
    if [[ "${CONTAINER_COLORIZE_OUTPUT,,}" == "false" ]]; then
      echo -e "$(log_prefix)[INFO] $SCRIPTPATH/$(basename "$0") ** [${PROCESS_NAME}] $1"
    else
      echo -e "$(log_prefix)${BDG}[INFO]${BOFF} $SCRIPTPATH/$(basename "$0") ** [${PROCESS_NAME}] $1"
    fi
  else
    if [[ "${CONTAINER_COLORIZE_OUTPUT,,}" == "false" ]]; then
      echo -e "$(log_prefix)[INFO] ** [${PROCESS_NAME}] $1"
    else
      echo -e "$(log_prefix)${BDG}[INFO]${BOFF} ** [${PROCESS_NAME}] $1"
    fi
  fi

  echo -e "$(log_prefix)[INFO] $SCRIPTPATH/$(basename "$0") ** [${PROCESS_NAME}] $1" >> "${LOG_FILE}"
  output_on
}

# Log a notice message
# Usage: print_notice <message>
print_notice() {
  output_off
  case "${CONTAINER_LOG_LEVEL,,}" in
    "debug" | "notice" )
      if [[ "${DEBUG_MODE,,}" == "true" ]]; then
        if [[ "${CONTAINER_COLORIZE_OUTPUT,,}" == "false" ]]; then
          echo -e "$(log_prefix)[NOTICE] $SCRIPTPATH/$(basename "$0") ** [${PROCESS_NAME}] $1"
        else
          echo -e "$(log_prefix)${BDGY}[NOTICE]${BOFF} $SCRIPTPATH/$(basename "$0") ** [${PROCESS_NAME}] $1"
        fi
      else
        if [[ "${CONTAINER_COLORIZE_OUTPUT,,}" == "false" ]]; then
          echo -e "$(log_prefix)[NOTICE] ** [${PROCESS_NAME}] $1"
        else
          echo -e "$(log_prefix)${BDGY}[NOTICE]${BOFF} ** [${PROCESS_NAME}] $1"
        fi
      fi
    ;;
  esac

  case "${CONTAINER_LOG_FILE_LEVEL,,}" in
    "debug" | "notice" )
      echo -e "$(log_prefix)[NOTICE] $SCRIPTPATH/$(basename "$0") ** [${PROCESS_NAME}] $1" >> "${LOG_FILE}"
    ;;
  esac
  output_on
}

# Log a service start message with process counter
# Usage: print_start <message>
print_start() {
  output_off
  local procStartCount
  local procStartWrapper=""
  local procHelpArg=""
  local showOutput=""

  if [[ "${CONTAINER_ENABLE_PROCESS_COUNTER,,}" == "true" ]]; then
    if [[ -f /tmp/.container/"$(basename $PWD)" ]]; then
      procStartCount=$(cat /tmp/.container/"$(basename $PWD)" | wc -l)
      procStartWrapper="[${procStartCount}] "
    fi

    if [[ -z "${procStartCount}" ]]; then
      procStartCount=1
    fi

    procHelpArg="$(date +"${CONTAINER_PROCESS_HELPER_DATE_FMT}") $(date +"${CONTAINER_PROCESS_HELPER_TIME_FMT}") $(basename "$(pwd)") ${procStartCount} $(cat /etc/hostname)"

    if [[ -d "${CONTAINER_PROCESS_HELPER_PATH}" ]]; then
      if [[ -f "${CONTAINER_PROCESS_HELPER_PATH}/$(basename $0).sh" ]]; then
        exec "${CONTAINER_PROCESS_HELPER_PATH}/$(basename $0).sh" "${procHelpArg}"
      elif [[ -f "${CONTAINER_PROCESS_HELPER_PATH}/${CONTAINER_PROCESS_HELPER_SCRIPT}.sh" ]]; then
        exec "${CONTAINER_PROCESS_HELPER_PATH}/${CONTAINER_PROCESS_HELPER_SCRIPT}.sh" "${procHelpArg}"
      fi
    fi

    if [[ "${CONTAINER_PROCESS_RUNAWAY_PROTECTOR,,}" == "true" ]]; then
      if [[ "${CONTAINER_PROCESS_RUNAWAY_SHOW_OUTPUT_FINAL,,}" == "true" ]]; then
        if [[ "${procStartCount}" -eq "${CONTAINER_PROCESS_RUNAWAY_LIMIT}" ]]; then
          SHOW_OUTPUT="TRUE"
        fi
      fi

      if [[ "${procStartCount}" -gt "${CONTAINER_PROCESS_RUNAWAY_LIMIT}" ]]; then
        print_error "POTENTIAL RUNWAY DETECTECTED: Disabling $(basename $PWD) service because it has tried restarting '${CONTAINER_PROCESS_RUNAWAY_LIMIT}' times"
        s6-svc -d /var/run/s6/legacy-services/$(basename "$PWD")
        sleep 3
        exit 1
      fi

      print_debug "[process_restart] - Sleeping for ${CONTAINER_PROCESS_RUNAWAY_DELAY} seconds"

      if [[ "${procStartCount}" -gt 1 ]]; then
        sleep "${CONTAINER_PROCESS_RUNAWAY_DELAY}"
      fi
    fi
  fi

  if [[ "${DEBUG_MODE,,}" == "true" ]]; then
    if [[ "${CONTAINER_COLORIZE_OUTPUT,,}" == "false" ]]; then
      echo -e "$(log_prefix)[STARTING] $SCRIPTPATH/$(basename "$0") ** [${PROCESS_NAME}] ${procStartWrapper}$1"
    else
      echo -e "$(log_prefix)${BDG}[STARTING]${BOFF} $SCRIPTPATH/$(basename "$0") ** [${PROCESS_NAME}] ${procStartWrapper}$1"
    fi

    echo -e "$(log_prefix)[STARTING] $SCRIPTPATH/$(basename "$0") ** [${PROCESS_NAME}] ${procStartWrapper}$1" >> "${LOG_FILE}"
  else
    if [[ "${CONTAINER_COLORIZE_OUTPUT,,}" == "false" ]]; then
      echo -e "$(log_prefix)[STARTING] ** [${PROCESS_NAME}] ${procStartWrapper}$1"
    else
      echo -e "$(log_prefix)${BDG}[STARTING]${BOFF} ** [${PROCESS_NAME}] ${procStartWrapper}$1"
    fi

    echo -e "$(log_prefix)[STARTING] $SCRIPTPATH/$(basename "$0") ** [${PROCESS_NAME}] ${procStartWrapper}$1" >> "${LOG_FILE}"
  fi

  output_on
}

# Log a warning message
# Usage: print_warn <message>
print_warn() {
  output_off
  case "${CONTAINER_LOG_LEVEL,,}" in
    "debug" | "notice" | "warn" )
      if [[ "${DEBUG_MODE,,}" == "true" ]]; then
        if [[ "${CONTAINER_COLORIZE_OUTPUT,,}" == "false" ]]; then
          echo -e "$(log_prefix)[WARN] ** [${PROCESS_NAME}] $1"
        else
          echo -e "$(log_prefix)${BDB}[WARN]${BOFF} $SCRIPTPATH/$(basename "$0") ** [${PROCESS_NAME}] $1"
        fi
      else
        if [[ "${CONTAINER_COLORIZE_OUTPUT,,}" == "false" ]]; then
          echo -e "$(log_prefix)[WARN] ** [${PROCESS_NAME}] $1"
        else
          echo -e "$(log_prefix)${BDB}[WARN]${BOFF} ** [${PROCESS_NAME}] $1"
        fi
      fi
    ;;
  esac

  case "${CONTAINER_LOG_FILE_LEVEL,,}" in
    "debug" | "notice" | "warn" )
      echo -e "$(log_prefix)[WARN] ** [${PROCESS_NAME}] $1" >> "${LOG_FILE}"
    ;;
  esac

  output_on
}

# Run a command silently unless DEBUG_MODE is enabled
# Usage: silent <command> [args...]
silent() {
  if [[ "${DEBUG_MODE}" == "true" || "${SHOW_OUTPUT,,}" == "true" || "${CONTAINER_LOG_LEVEL,,}" == "debug" ]]; then
    "$@"
  else
    "$@" > /dev/null 2>&1
  fi
}

# Validate database configuration
# Usage: sanity_db <database_type>
sanity_db() {
  output_off
  if [[ -n "${1:-}" ]]; then
    case "${1,,}" in
      "couch" | "couchdb" )
        print_debug "Checking Couch DB Parameters"
        transform_file_var DB_HOST
        local couchHost=${DB_HOST:-}
        transform_file_var COUCH_HOST

        if [[ -n "${COUCH_HOST:-}" ]]; then
          couchHost=${COUCH_HOST}
        fi

        if [[ -z "${couchHost}" ]]; then
          print_error "No Couch Database Host Entered! - Set '\$DB_HOST' or '\$COUCH_HOST'"
          return 1
        fi
      ;;
      "influx" | "influxdb")
        print_debug "Checking Influx DB Parameters"
        transform_file_var DB_HOST
        local influxHost=${DB_HOST:-}
        transform_file_var INFLUX_HOST

        if [[ -n "${INFLUX_HOST:-}" ]]; then
          influxHost=${INFLUX_HOST}
        fi

        if [[ -z "${influxHost}" ]]; then
          print_error "No Influx Database Host Entered! - Set '\$DB_HOST' or '\$INFLUX_HOST'"
          return 1
        fi
      ;;
      "mongo" | "mongodb" )
        print_debug "Checking Mongo DB Parameters"
        transform_file_var DB_HOST
        local mongoHost=${DB_HOST:-}
        transform_file_var MONGO_HOST

        if [[ -n "${MONGO_HOST:-}" ]]; then
          mongoHost=${MONGO_HOST}
        fi

        if [[ -z "${mongoHost}" ]]; then
          print_error "No Mongo Database Host Entered! - Set '\$DB_HOST' or '\$MONGO_HOST'"
          return 1
        fi
      ;;
      "mysql" | "mariadb" )
        print_debug "Checking MariaDB DB Parameters"
        transform_file_var DB_HOST
        local mariaHost=${DB_HOST:-}
        transform_file_var MYSQL_HOST

        if [[ -n "${MYSQL_HOST:-}" ]]; then
          mariaHost=${MYSQL_HOST}
        fi

        transform_file_var MARIA_HOST

        if [[ -n "${MARIA_HOST:-}" ]]; then
          mariaHost=${MARIA_HOST}
        fi

        transform_file_var DB_USER
        local mariaUser=${DB_USER:-}
        transform_file_var MYSQL_USER

        if [[ -n "${MYSQL_USER:-}" ]]; then
          mariaUser=${MYSQL_USER}
        fi

        transform_file_var MARIA_USER

        if [[ -n "${MARIA_USER:-}" ]]; then
          mariaUser=${MARIA_USER}
        fi

        transform_file_var DB_PASS
        local mariaPass=${DB_PASS:-}
        transform_file_var MYSQL_PASS

        if [[ -n "${MYSQL_PASS:-}" ]]; then
          mariaPass=${MYSQL_PASS}
        fi

        transform_file_var MARIA_PASS

        if [[ -n "${MARIA_PASS:-}" ]]; then
          mariaPass=${MARIA_PASS}
        fi

        transform_file_var DB_NAME
        local mariaName=${DB_NAME:-}
        transform_file_var MYSQL_NAME

        if [[ -n "${MYSQL_NAME:-}" ]]; then
          mariaName=${MYSQL_NAME}
        fi

        transform_file_var MARIA_NAME

        if [[ -n "${MARIA_NAME:-}" ]]; then
          mariaName=${MARIA_NAME}
        fi

        if [[ -z "${mariaHost}" ]]; then
          print_error "No MariaDB Database Host Entered! - Set '\$DB_HOST' or '\$MARIA_HOST'"
          return 1
        fi

        if [[ -z "${mariaName}" ]]; then
          print_error "No MariaDB Database Name Entered! - Set '\$DB_NAME' or '\$MARIA_NAME'"
          return 1
        fi

        if [[ -z "${mariaUser}" ]]; then
          print_error "No MariaDB Database USER Entered! - Set '\$DB_USER' or '\$MARIA_USER'"
          return 1
        fi

        if [[ -z "${mariaPass}" ]]; then
          print_error "No MariaDB Database Pass Entered! - Set '\$DB_PASS' or '\$MARIA_PASS'"
          return 1
        fi
      ;;
      "pgsql" | "psql" | "postgres" | "postgresql" )
        print_debug "Checking Postgres DB Parameters"
        transform_file_var DB_HOST
        local postgresHost=${DB_HOST:-}
        transform_file_var POSTGRES_HOST

        if [[ -n "${POSTGRES_HOST:-}" ]]; then
          postgresHost=${POSTGRES_HOST}
        fi

        transform_file_var DB_USER
        local postgresUser=${DB_USER:-}
        transform_file_var POSTGRES_USER

        if [[ -n "${POSTGRES_USER:-}" ]]; then
          postgresUser=${POSTGRES_USER}
        fi

        transform_file_var DB_PASS
        local postgresPass=${DB_PASS:-}
        transform_file_var PGPASSWORD

        if [[ -n "${PGPASSWORD:-}" ]]; then
          postgresPass=${PGPASSWORD}
        fi

        transform_file_var DB_NAME
        local postgresName=${DB_NAME:-}
        transform_file_var POSTGRES_NAME

        if [[ -n "${POSTGRES_NAME:-}" ]]; then
          postgresName=${POSTGRES_NAME}
        fi

        if [[ -z "${postgresHost}" ]]; then
          print_error "No PostgreSQL Database Host Entered! - Set '\$DB_HOST' or '\$POSTGRES_HOST'"
          return 1
        fi

        if [[ -z "${postgresName}" ]]; then
          print_error "No PostgreSQL Database Name Entered! - Set '\$DB_NAME' or '\$POSTGRES_NAME'"
          return 1
        fi

        if [[ -z "${postgresUser}" ]]; then
          print_error "No PostgreSQL Database USER Entered! - Set '\$DB_USER' or '\$POSTGRES_USER'"
          return 1
        fi

        if [[ -z "${postgresPass}" ]]; then
          print_error "No PostgreSQL Database Pass Entered! - Set '\$DB_PASS' or '\$POSTGRES_PASS'"
          return 1
        fi
      ;;
      "rabbit" | "rabbitmq" )
        transform_file_var DB_HOST
        local rabbitHost=${DB_HOST:-}
        transform_file_var RABBIT_HOST

        if [[ -n "${RABBIT_HOST:-}" ]]; then
          rabbitHost=${RABBIT_HOST}
        fi

        transform_file_var RABBITMQ_HOST

        if [[ -n "${RABBITMQ_HOST:-}" ]]; then
          rabbitHost=${RABBITMQ_HOST}
        fi

        if [[ -z "${rabbitHost}" ]]; then
          print_error "No RabbitMQ Database Host Entered! - Set '\$DB_HOST' or '\$RABBIT_HOST'"
          return 1
        fi
      ;;
      "redis" )
        print_debug "Checking Redis DB Parameters"
        transform_file_var DB_HOST
        local redisHost=${DB_HOST:-}
        transform_file_var REDIS_HOST

        if [[ -n "${REDIS_HOST:-}" ]]; then
          redisHost=${REDIS_HOST}
        fi

        if [[ -z "${redisHost}" ]]; then
          print_error "No Redis Database Host Entered! - Set '\$DB_HOST' or '\$REDIS_HOST'"
          return 1
        fi
      ;;
      "rethink" )
        print_debug "Checking RethinkDB DB Parameters"
        transform_file_var DB_HOST
        local rethinkHost=${DB_HOST:-}
        transform_file_var RETHINK_HOST

        if [[ -n "${RETHINK_HOST:-}" ]]; then
          rethinkHost=${RETHINK_HOST}
        fi

        if [[ -z "${rethinkHost}" ]]; then
          print_error "No Rethink Database Host Entered! - Set '\$DB_HOST' or '\$RETHINK_HOST'"
          return 1
        fi
      ;;
    esac
  else
    print_debug "Using Legacy db_ready command - please upgrade"
    transform_file_var DB_HOST

    if [[ -z "${DB_HOST:-}" ]]; then
      print_error "No Database Host Entered! - Set '\$DB_HOST'"
      return 1
    fi

    transform_file_var DB_NAME

    if [[ -z "${DB_NAME:-}" ]]; then
      print_error "No Database Name Entered! - Set '\$DB_NAME'"
      return 1
    fi

    transform_file_var DB_USER

    if [[ -z "${DB_USER:-}" ]]; then
      print_error "No Database User Entered! - Set '\$DB_USER'"
      return 1
    fi

    transform_file_var DB_PASS

    if [[ -z "${DB_PASS:-}" ]]; then
      print_error "No Database Password Entered! - Set '\$DB_PASS'"
      return 1
    fi
  fi
  output_on
}

# Validate an environment variable exists
# Usage: sanity_var <variable_name> <description>
sanity_var() {
  output_off
  print_debug "Looking for existence of $1 environment variable"

  if [[ ! -v "$1" ]]; then
    print_error "No '$2' Entered! - Set '\$$1'"
    return 1
  fi
  output_on
}

# Enable a service by creating a symlink
# Usage: service_start <service_name>
service_start() {
  ln -sf /etc/services.available/"${1}" /etc/services.d/ || {
    print_error "Failed to create symlink for service ${1}"
    return 1
  }
}

# Disable a service by marking it to not start
# Usage: service_stop <service_name>
service_stop() {
  echo "DONOTSTART added by $(basename \""$0"\")" >> /tmp/.container/"${1}"-init
}

# Set system timezone
# Usage: set_timezone <timezone>
set_timezone() {
  if [[ -f /usr/share/zoneinfo/"${TIMEZONE}" ]]; then
    if [[ "${TIMEZONE}" != "$(cat /etc/timezone)" ]]; then
      print_notice "Timezone: Setting to '${TIMEZONE}' from '$(cat /etc/timezone)'"
      cp -R /usr/share/zoneinfo/"${1}" /etc/localtime || {
        print_error "Failed to set timezone"
        return 1
      }

      echo "${1}" > /etc/timezone
    fi
  else
    print_warn "Timezone: ${TIMEZONE} does not exist - Using '$(cat /etc/timezone)'"
  fi
}

# Display container information banner
# Usage: showoff
showoff() {
  output_off
  local is=""
  local ir=""

  if [[ -n "${IMAGE_NAME:-}" ]]; then
    local iv
    iv=$(get_image_version)
    is="$(echo 'H4sIAAAAAAAAA/PMTUxPtVLgAgDj9n4BCAAAAA==' | base64 -d | gunzip) ${IMAGE_NAME}"

    if [[ -n "${iv// }" ]]; then
      is="${is}$(echo 'H4sIAAAAAAAAA1OoUQhLLSrOzM9TUOACAAiVoSgNAAAA' | base64 -d | gunzip)${iv}$(echo 'H4sIAAAAAAAAA1MIqSxIVVDPzE1MT41PzkjMS0/NyU9XV0jLL1JISS1JzMwp5gIAZRrZYCQAAAA=' | base64 -d | gunzip)"
    fi

    is="${is}"

    if [[ -n "${IMAGE_REPO_URL:-}" ]]; then
      ir="$(echo 'H4sIAAAAAAAAAwtKLcgvzizJL6rUd8lPLs1NzStJLMnMz7PiAgAxTVbtGgAAAA==' | base64 -d | gunzip) ${IMAGE_REPO_URL}"
    fi
  fi

  echo "H4sIAAAAAAAAA61RQRLEIAi78wpvXAq971t68CE8vgni2s7urWUGEyRBHVt7JTYzc+Ga4WD+T+Q/pm9jmQNbIZpNN9OOpGSqnA6I4jJlp1RZZ2OZUbrK3B9nxWw5VB9NiOFNCt5ta8s0kSD3suiBxOQDRh0WxSWQcbuYj9Mp4KuksKAoOVm3qlvRfq1Vl4Nj5fkvZnCsnEeFItgXAgAA" | base64 -d | gunzip
  echo "${is}"
  echo "${ir}"
  echo "H4sIAAAAAAAAA/PJTE7NK061UvD1DFGoUTi0UsHIwMhEwSWxLFXBOT+vKL+SCwCc9R6MIwAAAA==" | base64 -d | gunzip
  echo ""
  echo "H4sIAAAAAAAAA22MsRXCMAwF+0zxB4DQ01JRMISIZdDDtowkJy/bkwG46t4Vd8+Itzik0ovRTVdJ7Nh1YKUyGDjjps2PavB+mJq0F+qOTe2DrIZFW0gbnDAlXrlor9zihJDKZcfoiYL9BGoJmSmGMYy/gz18Pu61si1CBT56VwvQSlLoWXieJvzhocfh3rJegXdE9+vlsm3bHGKcNEvMC00/MF6uwtoAAAA=" | base64 -d | gunzip
  echo ""
  output_on
}

# Convert true/false to yes/no in environment variables
# Usage: truefalse_yesno <variable_name> [case]
truefalse_yesno() {
  local value
  value=$(set | grep "${1}"= | cut -d '=' -f2)
  local var
  var=$(set | grep "${1}"= | sed "s/=.*//g")

  if [[ "${value,,}" == "true" || "${value,,}" == "yes" ]]; then
    print_debug "Converting Variable Name ${var} value to 'yes'"
    unset "$1"

    if [[ -n "${2:-}" ]]; then
      case "${2,,}" in
        "uppercase" | "upper" | "uc" )
          export "$1=YES"
        ;;
        "lowercase" | "lower" | "lc" )
          export "$1=yes"
        ;;
      esac
    else
      export "$1=yes"
    fi
  elif [[ "${value,,}" == "false" || "${value,,}" == "no" ]]; then
    print_debug "Converting Variable Name ${var} value to 'no'"
    unset "$1"

    if [[ -n "${2:-}" ]]; then
      case "${2,,}" in
        "uppercase" | "upper" | "uc" )
          export "$1=NO"
        ;;
        "lowercase" | "lower" | "lc" )
          export "$1=no"
        ;;
      esac
    else
      export "$1=no"
    fi
  fi
}

# Update a template file with variables
# Usage: update_template <template_file> <var1> [var2...]
update_template() {
  local templateFiles=$1
  local templates
  templates=$(echo "${templateFiles}" | tr " " "\n")
  shift

  for templateFile in $templates; do
    if [[ ! -f "${templateFile}" ]]; then
      print_error "[update_template] Template file ${templateFile} does not exist"
      return 1
    fi

    local templateVariables=($@)
    local templateUser
    templateUser=$(stat -c %U "${templateFile}")
    local templateTmpFile
    templateTmpFile=$(mktemp) || {
      print_error "[update_template] Failed to create temporary file"
      return 1
    }

    cp -a "${templateFile}" "${templateTmpFile}" || {
      print_error "[update_template] Failed to copy template to temporary file"
      rm -f "${templateTmpFile}"
      return 1
    }

    for templateVariable in ${templateVariables[@]}; do
      # Keep the compatibilty: {{VAR}} => ${VAR}
      sed -ri "s/[{]{2}$templateVariable[}]{2}/\${$templateVariable}/g" "${templateTmpFile}" || {
        print_error "[update_template] Failed to update template variable ${templateVariable}"
        rm -f "${templateTmpFile}"
        return 1
      }

      print_debug "[update_template] Template: '${templateFile}' updating field '${templateVariable}'"
    done

    # Replace placeholders
    (
      export ${templateVariables[@]}
      local IFS=":"
      sudo -HEu ${templateUser} envsubst "${templateVariables[*]/#/$}" < "${templateTmpFile}" > "${templateFile}" || {
        print_error "[update_template] Failed to substitute variables in template"
        return 1
      }
    )

    rm -f "${templateTmpFile}"
  done
}

# Load environment variables from _FILE variants
# Usage: transform_file_var <var1> [var2...]
transform_file_var() {
  local variables
  variables=$(echo "$@" | tr " " "\n")

  for variable in $variables; do
    local fileVariable="${variable}_FILE"

    if [[ -v "${fileVariable}" ]]; then
      if [[ ! -f "${!fileVariable}" ]]; then
        print_error "[transform_file_var] ${variable}_FILE set as environment variable, however file doesn't exist"
        return 1
      fi

      export "${variable}"="$(cat "${!fileVariable}")" || {
        print_error "[transform_file_var] Failed to read file ${!fileVariable}"
        return 1
      }
    fi
  done
}

# Convert true/false to on/off in environment variables
# Usage: truefalse_onoff <variable_name> [case]
truefalse_onoff() {
  local value
  value=$(set | grep "${1}"= | cut -d '=' -f2)
  local var
  var=$(set | grep "${1}"= | sed "s/=.*//g")

  if [[ "${value,,}" == "true" || "${value,,}" == "yes" ]]; then
    print_debug "Converting Variable Name ${var} value to 'On'"
    unset "$1"

    if [[ -n "${2:-}" ]]; then
      case "${2,,}" in
        "uppercase" | "upper" | "uc" )
          export "$1=ON"
        ;;
        "lowercase" | "lower" | "lc" )
          export "$1=on"
        ;;
      esac
    else
      export "$1=ON"
    fi
  elif [[ "${value,,}" == "false" || "${value,,}" == "no" ]]; then
    print_debug "Converting Variable Name ${var} value to 'Off'"
    unset "$1"

    if [[ -n "${2:-}" ]]; then
      case "${2,,}" in
        "uppercase" | "upper" | "uc" )
          export "$1=OFF"
        ;;
        "lowercase" | "lower" | "lc" )
          export "$1=off"
        ;;
      esac
    else
      export "$1=off"
    fi
  fi
}

# Convert true/false to 1/0 in environment variables
# Usage: truefalse_onezero <variable_name>
truefalse_onezero() {
  local value
  value=$(set | grep "${1}"= | cut -d '=' -f2)
  local var
  var=$(set | grep "${1}"= | sed "s/=.*//g")

  if [[ "${value,,}" == "true" || "${value,,}" == "yes" ]]; then
    print_debug "Converting Variable Name ${var} value to '1'"
    unset "$1"
    export "$1=1"
  elif [[ "${value,,}" == "false" || "${value,,}" == "no" ]]; then
    print_debug "Converting Variable Name ${var} value to '0'"
    unset "$1"
    export "$1=0"
  fi
}

# Check if a variable is false
# Usage: var_false <value>
var_false() {
  [[ "${1,,}" == "false" || "${1,,}" == "no" ]]
}

# Check if a variable is not false
# Usage: var_notfalse <value>
var_notfalse() {
  [[ "${1,,}" != "false" ]]
}

# Check if a variable is not true
# Usage: var_nottrue <value>
var_nottrue() {
  [[ "${1,,}" != "true" ]]
}

# Check if a variable is true
# Usage: var_true <value>
var_true() {
  [[ "${1,,}" == "true" || "${1,,}" == "yes" ]]
}

# Wait for a directory to exist
# Usage: wait_for_directory <directory_path>
wait_for_directory() {
  print_debug "Looking for existence of directory: $1"
  while [[ ! -d "${1}" ]]; do
    sleep 1
  done
}

# Wait for a file to exist
# Usage: wait_for_file <file_path>
wait_for_file() {
  print_debug "Looking for existence of file: $1"
  while [[ ! -f "${1}" ]]; do
    sleep 1
  done
}

# Wait for a port to be open
# Usage: wait_for_port <host> <port>
wait_for_port() {
  print_debug "Looking for existence of listening port on $1:$2"
  local counter=0

  while ! nc -z "${1}" "${2}"; do
    sleep 5
    ((counter+=5))
    print_warn "Host '${1}' is not listening on port '${2}', retrying.. ($counter seconds so far)"
  done
}

# Wait for a socket to exist
# Usage: wait_for_socket <socket_path>
wait_for_socket() {
  print_debug "Looking for existence of socket: $1"
  while [[ ! -S "${1}" ]]; do
    sleep 1
  done
}

# Convert yes/no to true/false in environment variables
# Usage: yesno_truefalse <variable_name> [case]
yesno_truefalse() {
  local value
  value=$(set | grep "${1}"= | cut -d '=' -f2)
  local var
  var=$(set | grep "${1}"= | sed "s/=.*//g")

  if [[ "${value,,}" == "true" || "${value,,}" == "yes" ]]; then
    print_debug "Converting Variable Name ${var} value to 'yes'"
    unset "$1"

    if [[ -n "${2:-}" ]]; then
      case "${2,,}" in
        "uppercase" | "upper" | "uc" )
          export "$1=TRUE"
        ;;
        "lowercase" | "lower" | "lc" )
          export "$1=true"
        ;;
      esac
    else
      export "$1=TRUE"
    fi
  elif [[ "${value,,}" == "false" || "${value,,}" == "no" ]]; then
    print_debug "Converting Variable Name ${var} value to 'no'"
    unset "$1"

    if [[ -n "${2:-}" ]]; then
      case "$2" in
        "uppercase" | "upper" | "uc" )
          export "$1=FALSE"
        ;;
        "lowercase" | "lower" | "lc" )
          export "$1=false"
        ;;
      esac
    else
      export "$1=FALSE"
    fi
  fi
}

#--------------------------------------------------
# Main Execution
#--------------------------------------------------

# Setup debug mode based on environment variable
case "${DEBUG_MODE,,}" in
  "true" | "yes" | "on" )
    CONTAINER_LOG_LEVEL="DEBUG"
    set -x
  ;;
  "false" | "no" | "off" )
    :
  ;;
  * )
    if [[ "$(dirname "$0")" == "/var/run/s6/etc/cont-init.d" || "$(dirname "$0")" == "/etc/cont-init.d" ]]; then
      if [[ "${DEBUG_MODE}" == "$(basename \""$0"\")" ]]; then
        print_notice "Enabling Debug mode for $(basename \""$0"\") scripts"
        set -x
      fi
    fi

    if [[ "${DEBUG_MODE}" == "$(basename "$PWD")" ]]; then
      print_notice "Enabling Debug mode for $(basename "$PWD") scripts"
      set -x
    fi
  ;;
esac

# Create log directory if it doesn't exist
mkdir -p "${CONTAINER_LOG_FILE_PATH}" 2>/dev/null || true
