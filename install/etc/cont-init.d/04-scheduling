#!/command/with-contenv bash
#----------------------------------------------------------------------
# Scheduling Configuration Script (04-scheduling)
#
# Purpose: Configures container scheduled tasks using cron. Processes
# CRON_* environment variables from both runtime and default files to
# generate crontab entries in the scheduling location.
#
# Environment Variables:
#   - CONTAINER_ENABLE_SCHEDULING: Enable scheduling (true/false)
#   - CONTAINER_SCHEDULING_BACKEND: Backend type (currently only "cron")
#   - CONTAINER_SCHEDULING_LOCATION: Where to store cron job files
#   - ENABLE_CRON: Legacy variable for backward compatibility
#   - SCHEDULING_LOG_TYPE: Log type (file or default)
#   - SCHEDULING_LOG_LOCATION: Directory for cron logs
#   - CRON_*: Any variable starting with CRON_ becomes a cron job
#
# Files Generated:
#   - ${CONTAINER_SCHEDULING_LOCATION}/<job_name> (individual cron jobs)
#   - ${SCHEDULING_LOG_LOCATION}/cron.log (if file logging enabled)
#----------------------------------------------------------------------

#----------------------------------------------------------------------
# INITIALIZATION
#----------------------------------------------------------------------
# Load container function library
source /assets/functions/00-container

# Disable debug output for cleaner initialization
output_off

# Prepare service for single-instance execution
prepare_service single

# Set process name for logging
PROCESS_NAME="scheduling"

#----------------------------------------------------------------------
# LEGACY COMPATIBILITY
#----------------------------------------------------------------------
# Handle legacy ENABLE_CRON variable for backward compatibility
# This maintains support for older container configurations
if var_false "${ENABLE_CRON}" ; then
  CONTAINER_ENABLE_SCHEDULING=FALSE
fi

if var_true "${ENABLE_CRON}" ; then
  CONTAINER_ENABLE_SCHEDULING=TRUE
  CONTAINER_SCHEDULING_BACKEND="cron"
fi

#----------------------------------------------------------------------
# MAIN EXECUTION
#----------------------------------------------------------------------
# Check if scheduling should be disabled entirely
if var_false "${CONTAINER_ENABLE_SCHEDULING}" ; then
  print_debug "Disabling Scheduling"
  service_stop "$(basename "$0")"
else
  # Process scheduling backend selection
  case "${CONTAINER_SCHEDULING_BACKEND,,}" in
    "cron" )
      # Create temporary directory for cron processing
      mkdir -p /tmp/.container/cron

      #----------------------------------------------------------------
      # LOG CONFIGURATION
      #----------------------------------------------------------------
      # Set up file-based logging if requested
      if [ "${SCHEDULING_LOG_TYPE,,}" = "file" ] ; then
        mkdir -p "${SCHEDULING_LOG_LOCATION}"
        touch "${SCHEDULING_LOG_LOCATION}"/cron.log
        # Create log rotation for cron logs
        create_logrotate cron "${SCHEDULING_LOG_LOCATION}"/cron.log
      fi

      #----------------------------------------------------------------
      # SCHEDULING DIRECTORY SETUP
      #----------------------------------------------------------------
      # Ensure scheduling location exists for storing cron job files
      if [ ! -d "${CONTAINER_SCHEDULING_LOCATION}" ]; then
        mkdir -p "${CONTAINER_SCHEDULING_LOCATION}"
      fi

      #----------------------------------------------------------------
      # PROCESS RUNTIME/BUILD CRON VARIABLES
      #----------------------------------------------------------------
      # First pass: Process CRON_* variables from Docker build or runtime
      # These take precedence over defaults
      cronenv=$(mktemp)

      # Enable POSIX mode for consistent variable listing
      set -o posix
      # Disable globbing to safely handle special characters in values
      set -f

      # Extract all CRON_* variables and remove the CRON_ prefix
      set | grep -E '^CRON_'| sed "s|CRON_||g" > ${cronenv}

      # Remove PERIOD variables as they're not standard cron format
      sed -i "/^PERIOD/d" "${cronenv}"

      # Process each cron entry from runtime/build environment
      while IFS= read -r cron_entry; do
        # Extract job name (convert to lowercase for consistency)
        schedule_title="$(echo ${cron_entry} | cut -d = -f1 | tr '[:upper:]' '[:lower:]' )"
        # Extract cron schedule value
        schedule_value="$(echo ${cron_entry} | cut -d = -f2 )"
        # Remove surrounding quotes from the value
        schedule_value="$(echo ${schedule_value:1:-1})"

        # Check if the schedule is explicitly disabled
        if var_false "${schedule_value}" ; then
          print_debug "Disabling ${schedule_title} scheduled task"
          # Create a nulled/disabled job file
          cat <<EOF > "${CONTAINER_SCHEDULING_LOCATION}/${schedule_title}"
# Nulled execution of command  generated by Environment Variable defined in Image build, or Runtime argument
# Entered Value: ${schedule}
# Generated on $(TZ=${TIMEZONE} date +'%Y-%m-%d %H:%M:%S %Z')
EOF
        else
          print_debug "Adding ${schedule_title} with to be parsed by ${CONTAINER_SCHEDULING_BACKEND}"
          # Create active job file
          cat <<EOF > "${CONTAINER_SCHEDULING_LOCATION}/${schedule_title}"
# Scheduled execution of command created automatically generated by Environment Variable defined in Image build, or Runtime argument
# Entered Value: ${schedule}
# Generated on $(TZ=${TIMEZONE} date +'%Y-%m-%d %H:%M:%S %Z')

${schedule_value}
EOF
        fi
      done < ${cronenv}

      # Cleanup from first pass
      rm -rf $cronenv
      # Re-enable globbing
      set +f
      # Clear all processed variables to avoid interference
      unset cronenv schedules cron_entry schedule_value schedule_title
      unset "${!CRON_@}"

      #----------------------------------------------------------------
      # PROCESS DEFAULT FILE CRON VARIABLES
      #----------------------------------------------------------------
      # Second pass: Process CRON_* variables from default files
      # These only apply if not already set by runtime/build
      for d in /assets/defaults/* ; do
        # Skip the main container defaults (already loaded globally)
        if [ "$d" != "/assets/defaults/00-container" ] ; then
          # Source the defaults file to load its variables
          # shellcheck source=/assets/defaults/
          output_off
          source $d
          output_on

          # Extract CRON_* variables from this specific defaults file
          cronenv=$(mktemp)
          set -o posix
          set -f
          set | grep -E '^CRON_'| sed "s|CRON_||g" > "${cronenv}"
          sed -i "/^PERIOD/d" "${cronenv}"

          # Process each cron entry from this defaults file
          while IFS= read -r cron_entry; do
            schedule_title="$(echo ${cron_entry} | cut -d = -f1 | tr '[:upper:]' '[:lower:]')"
            schedule_value="$(echo ${cron_entry} | cut -d = -f2 )"
            schedule_value="$(echo ${schedule_value:1:-1})"

            # Only create job if it doesn't already exist (runtime takes precedence)
            if [ ! -f "${CONTAINER_SCHEDULING_LOCATION}/${schedule_title,,}" ] ; then
              print_debug "Adding $schedule_title with value $schedule_value to crontab"
              cat <<EOF > "${CONTAINER_SCHEDULING_LOCATION}/${schedule_title,,}"
# Scheduled execution of command taken from default file: '${d}'
# Entered Value: ${schedule}
# Generated on $(TZ=${TIMEZONE} date +'%Y-%m-%d %H:%M:%S %Z')

${schedule_value}
EOF
            else
              print_debug "Skipping adding '${schedule_title}' as it already exists"
            fi
          done < "${cronenv}"

          # Cleanup for this defaults file iteration
          rm -rf $cronenv
          set +f
          unset cronenv schedules cron_entry schedule_value schedule_title
          unset "${!CRON_@}"
        fi
      done

      print_notice "Container configured for scheduled tasks with 'cron'"
    ;;

    *)
      print_error "Unknown Scheduling Backend"
      exit 1
    ;;
  esac
fi

#----------------------------------------------------------------------
# FINALIZATION
#----------------------------------------------------------------------
# Mark this initialization script as complete
liftoff

# Re-enable debug output if it was previously enabled
output_on
